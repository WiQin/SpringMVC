三层架构：
spring

dao:mybatis
spring_dao.xml:dao层接口的实现类对象

servlct
spring+service.xml：service层实现类的代理，添加事务管理

web:springmvc

1.Web、MVC、WebMVC概述
	1)完成一次web请求的过程
		Web浏览器发起请求
		Web服务器接收请求并处理请求,最后产生响应(一般为html)。
		web服务器处理完成后,返回内容给web客户端,客户端对接收的内容进行处理并显示出来。

		从这里可以看出,在web中,都是web客户端发起请求,web服务器接收处理请求并产生响应。
		一般Web服务器是不能主动通知Web客户端更新内容。虽然有些技术可以帮我们实现这样的效果,如服务器推技术（Comet）、还有HTML5中的websocket等。

	2)MVC模型(Model-View-Controller)
		是一种架构型的模式,本身不引入新功能,只是帮助我们将开发的代码结构,组织的更加合理。

		Model(模型)
			数据模型,提供要展示的数据,因此包含数据和行为,行为是用来处理这些数据的。不过现在一般都分离开来:Value Object（数据） 和 服务层（行为）。也就是数据由实体类或者javabean来提供,行为由service层来提供.

		View(视图)
			负责进行模型的展示,一般就是我们见到的用户界面,客户想看到的东西。

		Controller(控制器)
			接收用户请求,委托给模型进行处理,处理完毕后把返回的模型数据交给给视图。也就是说控制器在中间起到一个调度的作用。


		注意:在标准的MVC中,模型能主动推数据给视图进行更新(可以采用观察者设计模式实现,在模型上注册视图,当模型更新时自动更新视图),但在Web开发中模型是无法主动推给视图,即无法主动更新用户界面,因为在Web的访问是请求-响应的模式。必须由客户端主动发出请求后,服务器才能把数据返回。



	3)WebMVC
		Web中MVC里面的模型-视图-控制器的概念和标准MVC概念一样,但是在Web MVC模式下,模型无法【主动】推数据给视图,如果用户想要视图更新,需要再发送一次请求(即请求-响应模型)。

		在我们之前的学习中,其实就是把Servlet作为Controller(控制器),把jsp作为View(视图),把javabean作为Model(模型)中的数据,service层作为Model(模型)中的行为.

		注意:MVC和三层架构的区别



2.SpringWebMVC概述(SpringMVC)
	1)SpringWebMVC简称SpringMVC
		SpringMVC就是Spring框架提供的一个模块,通过实现MVC模式来很好地将数据、业务与展现进行分离,SpringMVC框架的目的是要简化我们日常的Web开发。

		SpringMVC框架跟其他的WebMVC框架一样,都是*请求驱动*,并且设计围绕一个能够分发请求到控制器以及提供其他加快web应用开发功能的核心Servlet(叫做DispatcherServlet,即前端控制器)。Spring的DispatcherServlet实现比其他框架中还要多的功能。它和spring的ioc容器完全整合,并且允许使用spring中其他的所有功能。

		SpringMVC框架设计的一个核心的原则就是"开闭原则",对扩展开放,对修改关闭.所以SpringMVC框架中很多方法都是final的,不允许用户随意覆盖,但是却提供给用户很多可扩展的机制。SpringMVC目前已经成为非常流行的web应用的框架。


	2)SpringMVC框架的获取
		由于SpringMVC是Spring框架中的一个模块,所以我们下载Spring框架即可,因为里面包含了Spring框架的各个模块的相关东西,当然也包含了SpringMVC的.(jar包、API文档、源代码)

		spring-aop-3.2.4.RELEASE.jar
		spring-aspects-3.2.4.RELEASE.jar
		spring-beans-3.2.4.RELEASE.jar
		spring-context-3.2.4.RELEASE.jar
		spring-context-support-3.2.4.RELEASE.jar
		spring-core-3.2.4.RELEASE.jar
		spring-expression-3.2.4.RELEASE.jar
		spring-instrument-3.2.4.RELEASE.jar
		spring-instrument-tomcat-3.2.4.RELEASE.jar
		spring-jdbc-3.2.4.RELEASE.jar
		spring-jms-3.2.4.RELEASE.jar
		spring-orm-3.2.4.RELEASE.jar
		spring-oxm-3.2.4.RELEASE.jar
		spring-struts-3.2.4.RELEASE.jar
		spring-test-3.2.4.RELEASE.jar
		spring-tx-3.2.4.RELEASE.jar
		spring-web-3.2.4.RELEASE.jar
		spring-webmvc-3.2.4.RELEASE.jar
		spring-webmvc-portlet-3.2.4.RELEASE.jar

	3)SpringMVC框架的核心组件
		1.DispatcherServlet: 前端控制器,用来过滤客户端发送过来,想要进行逻辑处理的请求。

		2.Controller/Headler: 控制器/处理器。开发人员自定义,用来处理用户请求的,并且处理完成之后返回给用户指定视图的对象。

		3.HandlerMapping: 处理器映射器。DispatcherServlet接收到客户端请求的URL之后,根据一定的匹配规则,再把请求转发给对应的Handler,这个匹配规则由HandlerMapping决定。

		4.HandlerAdaptor:处理器适配器。处理器适配器用来适配每一个要执行的Handler对象。通过HandlerAdapter可以支持任意的类作为处理器

		5.ViewResolver:视图解析器。Handler返回的是逻辑视图名,需要有一个解析器能够将逻辑视图名转换成实际的物理视图。而且Spring的可扩展性决定了视图可以由很多种,所以需要不同的视图解析器,解析不同的视图。但是一般由jsp充当视图的情况居多


		SpringMVC框架提供一个核心的Servlet对象(DispatcherServlet,前端控制器)来对服务器接收到的请求进行解析,当这个请求被DispatcherServlet获取到之后,DispatherServlet需要根据HandlerMapping对象的映射关系,将这个请求转交给真正能够处理客户端请求的Controller控制器(我们要写的就是这个东西,相当于之前的servlet)来处理。Controller处理完成后返回ModelAndView对象,也就是模型和视图的结合体。ViewResolver视图解析器根据ModelAndView中的逻辑视图名找到真正的物理视图,同时使用ModelAndView中模型里面的数据对视图进行渲染。最后把准备好的视图展现给用户



3.SpringMVC框架在项目中的搭建
	第一步：构建Web项目
	第二步：导入所需jar包
	第三步：配置前端控制器DispatcherServlet
	第四步：编写Controller控制器(也称为Handler处理器)
	第五步：配置处理器映射器(可省去,有默认配置)
	第六步：配置处理器适配器(可省去,有默认配置)
	第七步：配置视图解析器(可省去,有默认配置,但是前缀和后缀都为"")
	第八步：配置控制器/处理器

	1)构建Web项目
		在自己Eclipse中创建一个动态web项目(DynamicWebProject),注意JDK版本和项目版本的选择


	2)导入所需的jar包
		在lib目录下放入如下jar包,这是初始jar包,根据后续需求会陆续加入jar包
		commons-logging-1.2.jar
		spring-beans-3.2.4.RELEASE.jar
		spring-context-3.2.4.RELEASE.jar
		spring-core-3.2.4.RELEASE.jar
		spring-expression-3.2.4.RELEASE.jar
		spring-web-3.2.4.RELEASE.jar
		spring-webmvc-3.2.4.RELEASE.jar


	3)配置前端控制器DispatcherServlet

		SpringMVC的核心控制器就是一个Servlet对象,继承自HttpServlet,所以需要在web.xml文件中配置。

		SpringMVC是Spring提供的一个模块,Spring所有的模块都是基于Spring IOC功能的。所以SpringMVC的DispatcherServlet对象在初始化之前也会去实例化Spring的容器对象（ApplicationContext）,那么就需要读取Spring的配置文件。默认SpringMVC会在你web应用的WEB-INF目录下查找一个名字为[servlet-name]-servlet.xml文件,并且创建在这个文件中定义的bean对象。如果你提供的spring配置文件的名字或者位置和默认的不同,那么需要在配置servlet时同时指定配置文件的位置。

		例如:
		  <servlet>
			<servlet-name>SpringMVC</servlet-name>
			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
			<load-on-startup>1</load-on-startup>
		  </servlet>
		  <servlet-mapping>
			<servlet-name>SpringMVC</servlet-name>
			<url-pattern>*.action</url-pattern>
		  </servlet-mapping>

		如上配置,框架会自动去当前应用的WEB-INF目录下查找名字为SpringMVC-servlet.xml文件(默认前缀和<servlet-name>标签中的值一致)。
		也可以自己指定配置文件的名字和位置:

		<servlet>
			<servlet-name>SpringMVC</servlet-name>
			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
			<init-param>
				<param-name>contextConfigLocation</param-name>
				<param-value>classpath:spring-web-mvc.xml</param-value>
			</init-param>
			<load-on-startup>1</load-on-startup>
		</servlet>
		<servlet-mapping>
			<servlet-name>SpringMVC</servlet-name>
			<url-pattern>*.action</url-pattern>
		</servlet-mapping>


		注意:
			配置文件在WEB-INF下:
			<param-value>/WEB-INF/spring-web-mvc.xml</param-value>
			配置文件在classpath下:
			<param-value>classpath:spring-web-mvc.xml</param-value>

		注意:
			<url-pattern>*.action</url-pattern>
			也可以配置成
			<url-pattern>/</url-pattern>

			注意:这里是/ 不是/*,后面会说明它们之间的区别

	4)编写Controller控制器(headler)
		Controller控制器,是MVC中的部分C,因为此处的控制器主要负责功能处理部分：
		1、收集、验证请求参数并封装到对象上；
		2、将对象交给业务层,由业务对象处理并返回模型数据；
		3、返回ModelAndView(Model部分是业务层返回的模型数据,视图部分为逻辑视图名)。

		前端控制器(DispatcherServlet)主要负责整体的控制流程的调度部分：
		1、负责将请求委托给控制器进行处理；
		2、根据控制器返回的逻辑视图名选择具体的视图进行渲染(并把模型数据传入)。
		因此MVC中完整的C(包含控制逻辑+功能处理)由(DispatcherServlet + Controller)组成。

		Controller接口中只有一个需要实现的方法就是handleRequest方法,方法中接收两个参数,分别对应Servlet对象中的request,response对象。可以从request中获取客户端提交过来的请求参数。
		返回值ModelAndView,既包含要返回给客户端浏览器的逻辑视图又包含要对视图进行渲染的数据模型。

		例如:
		import org.springframework.web.servlet.mvc.Controller;

		public class HelloWorldController implements Controller{
			@Override
			public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
				String name = request.getParameter("name");
				//ModelAndView对象中包括了要返回的逻辑视图,以及数据模型
				ModelAndView mv = new ModelAndView();
				//设置逻辑视图名称
				mv.setViewName("hello");
				//设置数据模型
				mv.addObject("name", name);

				return mv;
			}
		}

	5)配置映射器(可省去,有默认配置)
		注意:如果xml文件不能自动提示,那么可以在Eclipse中把schame配置过来即可,schame文件也在下载的spring的压缩包中
		Spring容器需要根据映射器来将用户提交的请求url和后台Controller/Handler进行绑定,所以需要配置映射器。
		例如:
		<bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/>

		BeanNameUrlHandlerMapping：表示将请求的URL和Bean名字映射,如URL为 "/hello",则Spring配置文件必须有一个名字为"/hello"的Bean.
		注意:这里/代表的含义是url中项目名后面的/


	6)配置适配器(可省去,有默认配置)
		想要正确运行自定义处理器,需要配置处理器适配器,在spring的配置文件中(就是本例中的SpringMVC-servlet.xml),进行如下配置：

		<bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/>

		SimpleControllerHandlerAdapter：表示所有实现了org.springframework.web.servlet.mvc.Controller接口的Bean可以作为SpringMVC中的处理器。如果需要其他类型的处理器可以通过实现HadlerAdapter来解决。


	7)配置视图解析器(可省去,有默认配置,但是前缀和后缀都为"")
		当处理器执行完成后,返回给spring容器一个ModelAndView对象,这个对象需要能够被解析成与之相对应的视图,并且使用返回的Model数据对视图进行渲染。

		<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
			<property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
			<property name="prefix" value="/WEB-INF/jsp/"/>
			<property name="suffix" value=".jsp"/>
		</bean>

		如果配置设置为如上操作,那么在自定义的Handler中返回的逻辑视图的名字不能有后缀.jsp,并且具体页面一定放在/WEB-INF目录下。

		InternalResourceViewResolver：用于支持Servlet、JSP视图解析；
		viewClass：JstlView表示JSP模板页面需要使用JSTL标签库,classpath中必须包含jstl的相关jar包；
		prefix和suffix：视图页面的前缀和后缀(前缀+逻辑视图名+后缀),比如传进来的逻辑视图名为hello,则该该jsp视图页面应该存放在"WEB-INF/jsp/hello.jsp"

		注意:放在WEB-INF下的页面,只能通过内部跳转的方式访问到,因为客户端访问不到WEB-INF目录,而且服务器端可以访问到WEB-INF目录
		注意:需要引入jstl相关jar包
		注意:页面中的路径问题
			 <%
				String path = request.getContextPath();
				String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
			 %>

			 <base href="<%=basePath%>" />

	8)配置处理器
		把编写好的handler/controller在spring中进配置,让其接受Spring IoC容器管理
		<bean name="/hello.action" class="com.briup.web.controller.HelloWorldController"/>



	注意: 对于Spring配置文件中的处理器适配器,处理器映射器,都可以省去不写,springMVC框架中会有默认配置的,视图解析器也可以不配置,因为在org.springframework.web.servlet.DispatcherServlet这个类的同包下,有一个DispatcherServlet.properties文件,里面就是SpringMVC默认的配置,是当用户的Spring配置文件中没有指定配置时使用的默认策略(你不配置那么用户默认的,你配置了,那么就使用你的配置)

	从默认的配置中可以看出DispatcherServlet在启动时会自动注册这些特殊的Bean,无需我们注册,如果我们注册了,默认的将不会注册。

	因此之前的BeanNameUrlHandlerMapping、SimpleControllerHandlerAdapter是不需要注册的,DispatcherServlet默认会注册这两个Bean。


	整个访问的流程:
	1、  首先用户发送请求,前端控制器DispatcherServlet收到请求后自己不进行处理，而是委托给其他的解析器进行处理，前端控制器作为统一访问点，进行全局的流程控制；
	2、  DispatcherServlet把请求转交给HandlerMapping， HandlerMapping将会把请求映射为HandlerExecutionChain对象(包含一个Handler处理器对象、多个HandlerInterceptor拦截器)对象.(后面会学习到拦截器)
	3、  DispatcherServlet再把请求转交给HandlerAdapter，HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器(适配器模式).简单点说就是让我们知道接下来应该调用Handler处理器里面的什么方法
	4、  HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；
	5、  ModelAndView的逻辑视图名交给ViewResolver解析器， ViewResolver解析器把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；
	6、  View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；
	7、最后返回到DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。



4.DispatcherServlet中的映射路径
	<servlet>
		<servlet-name>SpringMVC</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<load-on-startup>1</load-on-startup>
	</servlet>
	<servlet-mapping>
		<servlet-name>SpringMVC</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>

	1)拦截所有请求
		<url-pattern>/</url-pattern>
		此处需要特别强调的是,配置中使用的是/,而不是/*,如果使用/*,那么请求时可以通过DispatcherServlet转发到相应的Controller中,但是Controller返回的时候,如返回的jsp还会再次被拦截,这样导致404错误,即访问不到jsp。

		拦截/,例如：/user/add
		将来可以实现REST风格的访问
		弊端：会导致静态文件（jpg,js,css）被拦截后不能正常显示。

		拦截/*,请求可以走到Controller中,但跳转到jsp时再次被拦截,不能访问到jsp,可以说这是错误的配置。

	2)自定义拦截请求的后缀名
		拦截*.do、*.html、*.action, 例如/user/add.do
		这是最传统的方式,最简单也最实用。不会导致静态文件（jpg,js,css）被拦截。

		弊端:
			Controller的后缀只能固定成某一个
			将来不便于实现REST风格的访问

	3)静态资源的访问,如jpg,js,css
		如果DispatcherServlet拦截"*.do"这样的有后缀的URL,就不存在访问不到静态资源的问题。
	　　如果DispatcherServlet拦截"/",为了实现REST风格,拦截了所有的请求,那么同时对*.js,*.jpg等静态文件的访问也就被拦截了。
		例如:
		<link href="static/css/hello.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="static/js/hello.js"></script>
		<img alt="none" src="static/images/logo.png">

		解决方式一：利用Tomcat的defaultServlet来处理静态文件
		<servlet-mapping>
			<servlet-name>default</servlet-name>
			<url-pattern>*.jpg</url-pattern>
		</servlet-mapping>

		<servlet-mapping>
			<servlet-name>default</servlet-name>
			<url-pattern>*.js</url-pattern>
		</servlet-mapping>

		<servlet-mapping>
			<servlet-name>default</servlet-name>
			<url-pattern>*.css</url-pattern>
		</servlet-mapping>

		或者:
		<servlet-mapping>
			<servlet-name>default</servlet-name>
			<url-pattern>*.css</url-pattern>
			<url-pattern>*.js</url-pattern>
			<url-pattern>*.png</url-pattern>
		</servlet-mapping>

		特点：1.要配置多个，每种文件配置一个。
		　　  2.要写在DispatcherServlet的前面(和tomcat版本有关),让defaultServlet先拦截请求,	这样请求就不会进入Spring了
		　　  3. 高性能。


		解决方式二: 使用<mvc:resources>标签,例如:
		<mvc:resources mapping="/images/**" location="/images/"/>
		<mvc:resources mapping="/js/**" location="/js/"/>
		<mvc:resources mapping="/css/**" location="/css/"/>

		mapping： 映射
		两个*,表示映射指定路径下所有的URL,包括子路径
		location：本地资源路径

		这样如果有访问/images或者/js或者/css路径下面的资源的时候,spring就不会拦截了


		解决方式三: 使用<mvc:default-servlet-handler/>标签
		在spring配置文件中加入此标签配置即可


5.spring提供的编码过滤器
	查看这个过滤器类源码便可知这里所传的俩个参数的作用
	<filter>
		<filter-name>CharacterEncodingFilter</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>UTF-8</param-value>
		</init-param>
		<init-param>
			<param-name>forceEncoding</param-name>
			<param-value>true</param-value>
		</init-param>
	</filter>
	<filter-mapping>
		<filter-name>CharacterEncodingFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>

-------------------------------------------------------------------------------------------------------------------------------------

1.Controller接口及其实现类
	Controller是控制器/处理器接口,此处只有一个方法handleRequest,用于进行请求的功能处理(功能处理方法),处理完请求后返回ModelAndView对象(Model模型数据部分 和 View视图部分)。

	如果想直接在处理器/控制器里使用response向客户端写回数据,可以通过返回null来告诉DispatcherServlet我们已经写出响应了,不需要它进行视图解析

	Spring默认提供了一些Controller接口的实现类以方便我们使用,在Eclipse中选择Controller接口然后右键open type Hierarchy即可查看该接口的实现类,每个实现类都有自己特殊的功能,这里以实现类AbstractController为例简单介绍下。
	查看AbstractController类中代码可知,我们写一个Controller的时候可以继承AbstractController然后实现handleRequestInternal方法即可。


	提供了【可选】的会话(session)的串行化访问功能,例如:
	//即同一会话,线程同步
	public class HelloWorldController extends AbstractController{
		@Override
		protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)
				throws Exception {

			String name = request.getParameter("name");

			//ModelAndView对象中包括了要返回的逻辑视图,以及数据模型
			ModelAndView mv = new ModelAndView();
			//设置视图名称,可以是字符串 也可以是视图对象
			mv.setViewName("hello");
			//设置数据模型
			mv.addObject("name", name);

			return mv;
		}


	}

	<bean name="/hello" class="com.briup.web.controller.HelloWorldController">
		<property name="synchronizeOnSession" value="true"></property>
	</bean>



	直接通过response写响应,例如:
	public class HelloWorldController extends AbstractController{
		@Override
		protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)
				throws Exception {

			response.getWriter().write("Hello World!!");
			//如果想直接在该处理器/控制器写响应 可以通过返回null告诉DispatcherServlet自己已经写出响应了,不需要它进行视图解析
			return null;
		}

	}


	强制请求方法类型,例如:
	//只支持post和get方法
	<bean name="/hello" class="com.briup.web.controller.HelloWorldController">
		<property name="supportedMethods" value="POST,GET"></property>
	</bean>


	当前请求的session前置条件检查,如果当前请求无session将抛出HttpSessionRequiredException异常,例如:
	//在进入该控制器时[前],一定要有session存在,否则抛出HttpSessionRequiredException异常。

	<bean name="/hello" class="com.briup.web.controller.HelloWorldController">
		<property name="requireSession" value="true"/>
	</bean>


2.自定义适配器
	一般情况下,springMVCSimpleControllerHandlerAdapter会是我们常用的适配器,也是SpringMVC中默认的适配器,该适配器中的主要代码如下:
	public class SimpleControllerHandlerAdapter implements HandlerAdapter {
		public boolean supports(Object handler) {
			return (handler instanceof Controller);
		}
		public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
				throws Exception {

			return ((Controller) handler).handleRequest(request, response);
		}
	}
	从代码中可以看出,它首先会判断我们的handler是否实现了Controller接口,如果实现了,那么会调用Controller接口中的handleRequest方法

	那么根据这种方式能看出,我们也可以有自己的适配器的实现,那么就可以让任意类成为SpringMVC中的handler了,无论我们的类是否实现了Controller接口

	例如:
		自己的接口:
		public interface MyHandler {
			public ModelAndView handler_test(HttpServletRequest request, HttpServletResponse response)throws Exception;
		}
		自己的适配器:
		public class MyHandlerAdapter implements HandlerAdapter{
			@Override
			public boolean supports(Object handler) {
				return (handler instanceof MyHandler);
			}

			@Override
			public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
					throws Exception {
				return ((MyHandler)handler).handler_test(request, response);
			}

			@Override
			public long getLastModified(HttpServletRequest request, Object handler) {
				return -1L;
			}

		}

		自己的hander:(就是我们之前写的Controller)
		public class TestController implements MyHandler{
			@Override
			public ModelAndView handler_test(HttpServletRequest request, HttpServletResponse response) throws Exception {
				String name = request.getParameter("name");
				ModelAndView mv = new ModelAndView("hello");
				mv.addObject("name", name);
				return mv;
			}
		}

		最后在spring的配置中把我们的适配器进行配置即可正常使用.适配器配置多个，从上到下适配



3.处理器拦截器/控制器拦截器
	SpringMVC的处理器拦截器类似于Servlet 开发中的过滤器Filter,用于对处理器进行预处理和后处理。
	1)常见应用场景
		1、日志记录
		2、权限检查
		3、性能监控
		4、通用行为 例如读取用户cookie
		等
	2)拦截器接口
		public interface HandlerInterceptor {
			boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)throws Exception;

			void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)throws Exception;

			void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)throws Exception;
		}

		preHandle方法
			预处理回调方法,实现处理器的预处理,第三个参数为的处理器(本次请求要访问的那个Controller)
			返回值:true表示继续流程(如调有下一个拦截器或处理器)
			false表示流程中断(如登录检查失败),不会继续调用其他的拦截器或处理器,此时我们需要通过response来产生响应

		postHandle方法
			后处理回调方法,实现处理器的后处理(但在渲染视图之前),此时我们可以通过modelAndView对模型数据进行处理或对视图进行处理,modelAndView也可能为null。

		afterCompletion方法
			整个请求处理完毕回调方法,即在视图渲染完毕时回调

	3)拦截器适配器
		有时候我们可能只需要实现三个回调方法中的某一个,如果实现HandlerInterceptor 接口的话,三个方法必须实现,不管你需不需要,此时spring 提供了一个HandlerInterceptorAdapter 适配器(适配器模式),允许我们只实现需要的回调方法。
		在HandlerInterceptorAdapter中,对HandlerInterceptor 接口中的三个方法都进行了空实现,其中preHandle方法的返回值,默认是true

	4)测试一个拦截器
		拦截器代码:
		public class MyInterceptor1 extends HandlerInterceptorAdapter{
			@Override
			public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
					throws Exception {
				System.out.println("MyInterceptor1 preHandle");
				return true;
			}
			@Override
			public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
					ModelAndView modelAndView) throws Exception {
				System.out.println("MyInterceptor1 postHandle");
			}
			@Override
			public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
					throws Exception {
				System.out.println("MyInterceptor1 afterCompletion");
			}
		}

		配置文件:(注意此配置在文件中的配置顺序,要写在配置文件的上面)
		<bean name="handlerInterceptor1" class="com.briup.web.interceptor.MyInterceptor1"/>

		<bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping">
			<property name="interceptors">
				<list>
					<ref bean="handlerInterceptor1"/>
				</list>
			</property>
		</bean>

		访问一个测试的Controller查看结果:
		MyInterceptor1 preHandle
		TestController执行
		MyInterceptor1 postHandle
		MyInterceptor1 afterCompletion

	5)测试俩个拦截器
		俩个拦截器的代码和上面类似,只是每个输出的内容不同
		配置文件:
		<bean name="handlerInterceptor1" class="com.briup.web.interceptor.MyInterceptor1"/>
		<bean name="handlerInterceptor2" class="com.briup.web.interceptor.MyInterceptor2"/>

		<bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping">
			<property name="interceptors">
				<list>
					<ref bean="handlerInterceptor1"/>
					<ref bean="handlerInterceptor2"/>
				</list>
			</property>
		</bean>

		访问一个测试的Controller查看结果:
		MyInterceptor1 preHandle
		MyInterceptor2 preHandle
		TestController执行
		MyInterceptor2 postHandle
		MyInterceptor1 postHandle
		MyInterceptor2 afterCompletion
		MyInterceptor1 afterCompletion

		注意:<list>标签中引用拦截器的顺序会影响结果输出的顺序


	6)如果Controller等采用的注解配置,那么拦截器需要mvc标签进行配置
		注意:每个<mvc:interceptor>只能配置一个拦截器
		<mvc:interceptors>
			<mvc:interceptor>
				<mvc:mapping path="/**"/>
				<ref bean="handlerInterceptor1"/>
			</mvc:interceptor>
		</mvc:interceptors>

		例如1: 注意/*和/**的区别
		<!--
        /**的意思是所有文件夹及里面的子文件夹
        /*是所有文件夹，不含子文件夹
        /是web项目的根目录
        -->
		<mvc:interceptors>
			<!-- 下面所有的mvc映射路径都会被这个拦截器拦截 -->
			<bean class="com.briup.web.interceptor.MyInterceptor1" />

			<mvc:interceptor>
				<mapping path="/**"/>
				<exclude-mapping path="/admin/**"/>
				<bean class="com.briup.web.interceptor.MyInterceptor2" />
			</mvc:interceptor>
			<mvc:interceptor>
				<mapping path="/secure/*"/>
				<bean class="com.briup.web.interceptor.MyInterceptor3" />
			</mvc:interceptor>
		</mvc:interceptors>


	7)拦截器是单例
		因此不管多少用户请求多少次都只有一个拦截器实现,即线程不安全。
		所以在必要时可以在拦截器中使用ThreadLocal,它是和线程绑定,一个线程一个ThreadLocal,A 线程的ThreadLocal只能看到A线程的ThreadLocal,不能看到B线程的ThreadLocal。

	8)记录执行Controller所用时间
		public class TimeInterceptor extends HandlerInterceptorAdapter{
			//拦截器是单例,不是线程安全的,所以这里使用ThreadLocal
			private ThreadLocal<Long> local = new ThreadLocal<>();

			@Override
			public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
					throws Exception {
				long start = System.currentTimeMillis();
				local.set(start);
				return true;
			}
			@Override
			public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
					throws Exception {
				long end = System.currentTimeMillis();
				System.out.println("共耗时:"+(end-local.get()));
			}
		}


	9)登录检查
		public class LoginInterceptor extends HandlerInterceptorAdapter{
			@Override
			public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
					throws Exception {
				//请求到登录页面放行
				if(request.getServletPath().startsWith("/login")) {
					return true;
				}

				//如果用户已经登录放行
				if(request.getSession().getAttribute("username") != null) {
					return true;
				}

				//其他没有登录的情况则重定向到登录页面
				response.sendRedirect(request.getContextPath() + "/login");

				return false;
			}
		}


	注意:推荐能使用servlet规范中的过滤器Filter实现的功能就用Filter实现,因为HandlerInteceptor只有在SpringWebMVC环境下才能使用,因此Filter是最通用的、最先应该使用的。



4.基于注解的SpringMVC

	1)用于支持注解的配置
		使用基于注解的配置可以省略很多操作,更方便。我们之前所看到的所有的xml配置,如果替换成基于注解只需要在spring的xml文件中做如下配置:
		<mvc:annotation-driven/>

		在Spring中,
		处理器类可以使用   @Controller注解
		业务逻辑层可以使用 @Service注解
		数据持久层可以使用 @Repository注解

		如果在处理器上使用 @Controller注解,那么还需要在配置文件中指定哪个包下面的类使用了该注解:
		<context:component-scan base-package="com.briup.web.controller"></context:component-scan>


	2)基于注解的Controller
		使用注解后,就不需要再实现特定的接口,任意一个javaBean对象都可以当做处理器对象,对象中任意一个方法都可以作为处理器方法。
		只需
			在类上加上 @Controller注解
			方法上加上 @RequestMapping注解
		即可

		例如:
		web.xml中:
		<servlet>
			<servlet-name>SpringMVC</servlet-name>
			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
			<init-param>
				<param-name>contextConfigLocation</param-name>
				<param-value>classpath:spring-web-mvc.xml</param-value>
			</init-param>
			<load-on-startup>1</load-on-startup>
		</servlet>
		<servlet-mapping>
			<servlet-name>SpringMVC</servlet-name>
			<url-pattern>/</url-pattern>
		</servlet-mapping>


		src下面的spring-web-mvc.xml中:
		<mvc:annotation-driven/>
		<context:component-scan base-package="com.briup.web.controller"></context:component-scan>

		<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
			<property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
			<property name="prefix" value="/WEB-INF/jsp/"/>
			<property name="suffix" value=".jsp"/>
		</bean>


		自定义的Controller中:
		@Controller
		public class HomeController {
			@RequestMapping("/home")
			public ModelAndView home(){
				ModelAndView mv = new ModelAndView("index");
				return mv;
			}
		}


		如上代码,使用 @Controller表明HomeController类是一个处理器类,通过 @RequestMapping("/home")表明当url请求名为/home时,调用home方法执行处理,当处理完成之后返回ModelAndView对象。因为在spring-web-mvc.xml中配置了视图解析器的前缀和后缀,所以最后视图home.jsp被返回


	3)基于注解的Controller的返回值
		1.返回ModelAndView,和之前一样

		2.返回String,表示跳转的逻辑视图名字,模型可以通过参数传过来
			@Controller
			public class HomeController {
				@RequestMapping("/home")
				public String home(Model model){
					model.addAttribute("msg", "hello world");
					return "index";
				}
			}

		3.声明返回类型为void
			可以通过参数获取request和response，分别使用服务器内部跳转和重定向，自己来决定要跳转的位置。
			@Controller
			public class HomeController {
				@RequestMapping("/home")
				public void home(HttpServletRequest request,HttpServletResponse response){
					String username = request.getParameter("username");
					response.setContentType("text/html;charset=utf-8");
					response.getWriter().write("hello world! "+username);
					//或者使用servlet的方式进行跳转/重定向

				}
			}



5.Spring2.5中引入注解对处理器(handler)支持
	@Controller
		用于标识是处理器类；
	@RequestMapping
		请求到处理器功能方法的映射规则；
	@RequestParam
		请求参数到处理器功能处理方法的方法参数上的绑定；
	@ModelAttribute
		请求参数到命令对象的绑定；
	@SessionAttributes
		用于声明session 级别存储的属性,放置在处理器类上,通常列出模型属性(如@ModelAttribute)对应的名称,则这些属性会透明的保存到session 中
	@InitBinder
		自定义数据绑定注册支持,用于将请求参数转换到命令对象属性的对应类型；


6.Spring3引入了更多的注解,其中包含了对RESTful架构风格的支持
	@CookieValue
		cookie数据到处理器功能处理方法的方法参数上的绑定；
	@RequestHeader
		请求头数据到处理器功能处理方法的方法参数上的绑定；
	@RequestBody
		请求的body体的绑定
	@ResponseBody
		处理器功能处理方法的返回值作为响应体
	@ResponseStatus
		定义处理器功能处理方法/异常处理器返回的状态码和原因；
	@ExceptionHandler
		注解式声明异常处理器；
	@PathVariable
		请求URI 中的模板变量部分到处理器功能处理方法的方法参数上的绑定,从而支持RESTful架构风格的URI；

		findUser.action?groupId=1&userId=3
		get   group/1/user/3   1,3 查找
		public void find(){...}
		delete  group/1/user/3   1,3 删除
		public void delete(){...}
get post put delete

7.Spring3中引入的mvc命名空间
	mvc这个命名空间是在Spring3中引入的,其作用是用来支持mvc的配置
	需要在<beans>中声明出这个命名空间及其对应的schemaLocation中的值
	<mvc:annotation-driven>
		自动注册基于注解风格的映射器和适配器:
		在spring2.5中是DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter

		在spring3中是RequestMappingHandlerMapping和RequestMappingHandlerAdapter.
		同时还支持各种数据的转换器.

	<mvc:interceptors>
		配置自定义的处理器拦截器,例如:
		<mvc:interceptors>
			<mvc:interceptor>
				<mvc:mapping path="/**"/>
				<ref bean="handlerInterceptor1"/>
			</mvc:interceptor>
		</mvc:interceptors>

	<mvc:view-controller>
		收到相应请求后直接选择相应的视图,例如:
		<mvc:view-controller path="/hello" view-name="test"></mvc:view-controller>

	<mvc:resources>
		逻辑静态资源路径到物理静态资源路径的对应.例如:
		<mvc:resources mapping="/images/**" location="/images/"/>
		<mvc:resources mapping="/js/**" location="/js/"/>
		<mvc:resources mapping="/css/**" location="/css/"/>

	<mvc:default-servlet-handler>
		当在web.xml中DispatcherServlet使用<url-pattern>/</url-pattern> 映射的时候,会静态资源也映射了,如果配置了这个mvc标签,那么再访问静态资源的时候就转交给默认的Servlet来响应静态文件,否则报404 找不到静态资源错误。



8.@Controller和@RequestMapping注解
	1)声明处理器
	@Controller
	public class HelloWorldController {

	}

	2)映射处理器中的【功能处理方法】
	@Controller
	public class HelloWorldController {
		@RequestMapping("/home")
		public ModelAndView home(){
			ModelAndView mv = new ModelAndView("index");
			return mv;
		}
	}

	表明该方法映射的url路径为/home

	3)@RequestMapping也可以写在处理器类上
	@RequestMapping("/test")
	@Controller
	public class HomeController {
		@RequestMapping("/home")
		public ModelAndView home(){
			ModelAndView mv = new ModelAndView("index");
			return mv;
		}
	}
	表明该方法映射的url路径为/test/home


9.请求映射
	假设浏览器发送了一个请求如下:
	-------------------------------
	POST /login	HTTP1.1
	Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
	Accept-Encoding: gzip, deflate
	Accept-Language: zh-CN,en;q=0.8,zh;q=0.5,en-US;q=0.3
	Connection: keep-alive
	Cookie: JSESSIONID=DBC6367DEB1C024A836F3EA35FCFD5A2
	Host: 127.0.0.1:8989
	Upgrade-Insecure-Requests: 1
	User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:49.0) Gecko/20100101 Firefox/49.0

	username=tom&password=123
	--------------------------------


	http协议的请求格式如下:
	---------------------------------
	请求方法 URL 协议版本号
	请求头信息
	请求头信息
	请求头信息
	..
	回车换行
	请求正文
	---------------------------------


	从格式中我们可以看到【请求方法、URL、请求头信息、请求正文】这四部分一般是可变的,因此我们可以把请求中的这些信息在处理器的【功能处理方法】中进行的映射,因此请求的映射分为如下几种:
		URL路径映射
			使用URL映射到处理器的功能处理方法；
		请求方法映射限定
			例如限定功能处理方法只处理GET请求；
		请求参数映射限定
			例如限定只处理包含username参数的请求；
		请求头映射限定
			例如限定只处理"Accept=application/json"的请求。


10.URL路径映射
	1)普通URL路径映射
		@RequestMapping(value="/test")
		@RequestMapping("/hello")
			注解中只出现一个参数且参数名为value的话,可以将参数名去掉
		@RequestMapping(value={"/test", "/user/hello"})
			多个URL路径可以映射到同一个处理器的功能处理方法。

	2)URI模板模式映射
		@RequestMapping(value="/users/{userId}")
			{XXX}占位符,得写， 请求的URL可以是"/users/123456"或"/users/abcd",之后可以通过@PathVariable可以提取URI模板模式中的{XXX}中的值
		@RequestMapping(value="/users/{userId}/create")
			这样也是可以的,请求的URL可以是"/users/123/create"
		@RequestMapping(value="/users/{userId}/topics/{topicId}")
			这样也是可以的,请求的URL可以是"/users/123/topics/123"

	3)Ant风格的URL路径映射
		@RequestMapping(value="/users/**")
			可以匹配"/users/abc/abc",但"/users/123"将会被【URI模板模式映射中的"/users/{userId}"模式优先映射到】
		@RequestMapping(value="/product/?")
			可匹配"/product/1"或"/product/a",但不匹配"/product"或"/product/aa";
			?代表有且只有一个字符
		@RequestMapping(value="/product*")
			可匹配"/productabc"或"/product",但不匹配"/productabc/abc";
			*代表0~n个字符
		@RequestMapping(value="/product/*")
			可匹配"/product/abc",但不匹配"/productabc";
		@RequestMapping(value="/products/**/{productId}")
			可匹配"/products/abc/abc/123"或"/products/123",也就是Ant风格和URI模板变量风格可混用;
			**代表所有的子路径

	4)正则表达式风格的URL路径映射
		从Spring3.0 开始支持正则表达式风格的URL路径映射,格式为{变量名:正则表达式},之后通过@PathVariable可以提取{XXX:正则表达式匹配的值}中的XXX这个变量的值。

		@RequestMapping(value="/products/{categoryCode:\\d+}-{pageNumber:\\d+}")
			可以匹配"/products/123-1",但不能匹配"/products/abc-1",这样可以设计更加严格的规则。
		@RequestMapping(value="/user/{userId:^\\d{4}-[a-z]{2}$}")
			可以匹配"/user/1234-ab"

		注意:\d表示数字,但是\在java的字符串中是特殊字符,所以需要再加一个\进行转义即可
		(参照之前js的学习文档,和java的正则几乎一致,js正则中的一个/变为java中的俩个/即可)
			括号:
				[abc] 	查找方括号之间的任何字符。
				[^abc] 	查找任何不在方括号之间的字符。
				[0-9] 	查找任何从 0 至 9 的数字。
				[a-z] 	查找任何从小写 a 到小写 z 的字符。
				[A-Z] 	查找任何从大写 A 到大写 Z 的字符。
				[A-z] 	查找任何从大写 A 到小写 z 的字符。
				(red|blue|green) 	查找任何指定的选项。

			元字符:
				. 	查找单个任意字符,除了换行和行结束符.如果要表示.这个字符,需要转义
				\w 	查找单词字符。     字母 数字 _
				\W 	查找非单词字符。非 字母 数字 _
				\d 	查找数字。
				\D 	查找非数字字符。
				\s 	查找空白字符。
				\S 	查找非空白字符。
				\b 	匹配单词边界。
				\B 	匹配非单词边界。
				\0 	查找 NUL 字符。
				\n 	查找换行符。
				\f 	查找换页符。
				\r 	查找回车符。
				\t 	查找制表符。
				\v 	查找垂直制表符。

			量词:
				n+ 		匹配任何包含至少一个 n 的字符串。
				n* 		匹配任何包含零个或多个 n 的字符串。
				n? 		匹配任何包含零个或一个 n 的字符串。
				n{X} 	匹配包含 X 个 n 的序列的字符串。
				n{X,Y} 	匹配包含 X 到 Y 个 n 的序列的字符串。
				n{X,} 	匹配包含至少 X 个 n 的序列的字符串。
				n$ 		匹配任何结尾为 n 的字符串。
				^n 		匹配任何开头为 n 的字符串。
				?=n 	匹配任何其后紧接指定字符串 n 的字符串。
				?!n 	匹配任何其后没有紧接指定字符串 n 的字符串。


		正则表达式风格的URL路径映射是一种特殊的URI模板模式映射
		URI模板模式映射不能指定模板变量的数据类型,如是数字还是字符串；
		正则表达式风格的URL路径映射,可以指定模板变量的数据类型,可以将规则写的相当复杂。

11.请求方法映射限定
	一般获取数据为GET请求方法,提交表单一般为POST请求方法。但之前URL路径映射方式对任意请求方法都是接受的,因此我们需要某种方式来告诉相应的功能处理方法只处理如GET方式的请求或POST方式的请求。

	@RequestMapping(value="/user/{userId:\\d+}",method=RequestMethod.GET)
		可以匹配"/user/100",并且请求方式只能是GET

	@RequestMapping(value="/hello", method={RequestMethod.POST,RequestMethod.GET})
		可以匹配"/hello",并且请求方式只能是POST或者GET

    @RequestMapping(value="/register",method={RequestMethod.POST})
	public String doPost(String name){
		System.out.println("name = "+name);
		System.out.println("注册成功");
		return "success";
	}
	@RequestMapping(value="/register",method={RequestMethod.GET})
	public String doGet(){
		return "register";
	}

	注意:
	1、一般浏览器只支持GET、POST请求方法,如想浏览器支持PUT、DELETE 等请求方法只能模拟。(jquery中的ajax函数可以发送这些方式的请求)
	2、除了GET、POST,还有HEAD、OPTIONS、PUT、DELETE、TRACE(观察servlet源码也可获知)
	3、DispatcherServlet默认开启对GET、POST、PUT、DELETE、HEAD 的支持；
	4、如果需要支持OPTIONS、TRACE,请添加DispatcherServlet 在web.xml 的初始化参数:dispatchOptionsRequest 和
	dispatchTraceRequest 为true。(查看源码,在DispatcherServlet的父类中可以找到这个俩个属性)

12.请求参数映射限定
   	1)请求数据中有指定参数名
   	@RequestMapping("/test")
   	@Controller
   	public class HomeController {
   		@RequestMapping(params="create",method=RequestMethod.GET)
   		public ModelAndView test1(){

   			return null;
   		}
   		@RequestMapping(params="create",method=RequestMethod.POST)
   		public ModelAndView test2(){

   			return null;
   		}
   	}

   	可以匹配的路径为:/test?create
   	如果是get 方式的请求则访问test1方法
   	如果是post方式的请求则访问test2方法


   	2)请求数据中没有指定参数名
   	@RequestMapping(params="!create", method=RequestMethod.GET)


   	3)请求数据中指定参数名=值
   	@RequestMapping(params="username=tom")


   	4)请求数据中指定参数名!=值
   	username参数名可以不出现,但是如果出现了,那么参数值一定不能等于tom
   	@RequestMapping(params="username!=tom")

   	5)组合使用是"且"的关系
   	@RequestMapping(params={"create","username=tom"})

13.请求头数据映射限定
   	1)请求头数据中有指定参数名
   	@RequestMapping(value="/header/test1", headers="Accept")
   		表示请求的URL必须为"/header/test1"且请求头中必须有Accept参数才能匹配。

   	@RequestMapping(value="/header/test1", headers="my_test")
   		表示请求的URL必须为"/header/test1"且请求头中必须有my_test参数才能匹配

   	2)请求头数据中没有指定参数名
   	@RequestMapping(value="/header/test2", headers="!abc")
   		表示请求的URL必须为"/header/test2"且请求头中必须没有abc参数才能匹配


   	3)请求头数据中指定参数名=值
   	@RequestMapping(value="/header/test3", headers="Content-Type=application/json")
   	表示请求的URL必须为"/header/test3"且请求头中必须有"Content-Type=application/json"参数即可匹配。


   	4)请求头数据中指定参数名!=值
   	@RequestMapping(value="/header/test4", headers="Accept!=text/html")
   	表示请求的URL必须为"/header/test4"且请求头中必须有Accept参数,但是值不等于text/html即可
   	例如:
   	@RequestMapping(value="/test1",headers="Content-Type!=application/json")
   	表示请求头信息中要么不出现Content-Type属性,如果出现了那么它的值一定不能等于application/json

   	5)组合使用是"且"的关系
   	@RequestMapping(value="/header/test5", headers={"Accept!=text/html", "abc=123"}):
   	表示请求的URL必须为"/header/test5"且请求头中必须有"Accept"参数但值不等于"text/html"且请求中必须有参数"abc=123"即可匹配。


   	6)consumes属性和produces属性
   	consumes 指定处理请求的提交内容类型(消费)
   	@RequestMapping(value="/test",consumes="application/json")
   		方法仅处理请求中,Content-Type为"application/json"的情况

   	produces 指定返回的内容类型(生产)
   	@RequestMapping(value= "/test", produces="application/json")
   		表示该功能处理方法将产生json格式的数据,此时根据请求头中的Accept进行匹配,如请求头"Accept=application/json"时即可匹配;


   	例如:
   	@RequestMapping(value="test6",consumes="application/json")
   	public String test6(){
   		System.out.println("test6...");
   		return "test";
   	}

   	@RequestMapping(value="test7",produces="application/json")
   	public String test7(){
   		System.out.println("test7...");
   		return "test";
   	}

   	测试类中的main函数代码:
   	此处我们使用Spring提供的Http客户端API创建了请求并设置了请求的Content-Type和编码并在响应体中写回了json数据
   	public static void main(String[] args) {

   		try {
   			String url = "http://127.0.0.1:8989/XXX/XXX";
   			//创建HttpRequest
   			ClientHttpRequest request =
   			new SimpleClientHttpRequestFactory().
   			createRequest(new URI(url), HttpMethod.POST);
   			//设置请求头的内容类型头和内容编码
   			//request.getHeaders().set("Content-Type", "application/json;charset=UTF-8");
   			request.getHeaders().set("Accept", "application/json");
   			//写出请求内容体
   			String jsonData = "{\"username\":\"zhang\", \"password\":\"123\"}";
   			request.getBody().write(jsonData.getBytes("UTF-8"));
   			//发送请求并得到响应
   			ClientHttpResponse response = request.execute();
   			System.out.println(response.getStatusCode());
   			System.out.println(response.getHeaders());
   		} catch (Exception e) {
   			e.printStackTrace();
   		}
   	}


   	注意:在上面代码中,如果想获得响应正文中的数据,可以编写一下代码:
   	//得到响应体的编码方式
   	Charset charset = response.getHeaders().getContentType().getCharSet();
   	//得到响应体的内容
   	InputStream is = response.getBody();
   	byte bytes[] = new byte[(int)response.getHeaders().getContentLength()];
   	is.read(bytes);
   	String data = new String(bytes, charset);
   	System.out.println("charset="+charset);
   	System.out.println("data : " + data);

14.数据绑定

   	1)功能处理方法支持的"参数类型"
   	注意下面这些参数都可以在功能处理方法中直接声明并且没有指定顺序,spring会自动注入的
   	  第一种
   		ServletRequest/HttpServletRequest 和 ServletResponse/HttpServletResponse
   		SpringWebMVC框架会自动帮助我们把相应的Servlet请求/响应作为参数传递过来。

   	  第二种
   		InputStream/OutputStream 和 Reader/Writer
   		分别对应的是request.getInputStream();
   				    response.getOutputStream();
   				    request.getReader();
   				    response.getWriter()。
   		InputStream/OutputStream 和 Reader/Writer两组不能同时使用,只能使用其中的一组。

   		注意:
   		//代码如下,访问的时候会报500错误,因为使用输出流,就不能再发回视图了,因为使用输出流那么就是使用了response,使用了response就是要自己处理返回给浏览器的内容,那么也就不能再让Controller返回视图了
   		@RequestMapping("/test")
   		public String test(InputStream in,OutputStream out){

   			System.out.println(in);
   			System.out.println(out);

   			return "test";
   		}


   	  第三种
   		WebRequest/NativeWebRequest
   		WebRequest是SpringMVC提供的统一请求访问接口,不仅仅可以访问请求相关数据(如参数区数据、请求头数据,但访问不到Cookie区数据),还可以访问会话和上下文中的数据；NativeWebRequest继承了WebRequest,并提供访问本地ServletAPI的方法。
   		例如:
   		public String webRequest(WebRequest webRequest, NativeWebRequest nativeWebRequest) {
   			System.out.println(webRequest.getParameter("test"));
   			webRequest.setAttribute("name", "tom",WebRequest.SCOPE_REQUEST);
   			System.out.println(webRequest.getAttribute("name", WebRequest.SCOPE_REQUEST));
   			HttpServletRequest request =
   				nativeWebRequest.getNativeRequest(HttpServletRequest.class);
   			HttpServletResponse response =
   				nativeWebRequest.getNativeResponse(HttpServletResponse.class);
   				return "success";
   		}

   		webRequest.getParameter() 访问请求参数区的数据webRequest.getHeader()    访问请求头数据
   		webRequest.setAttribute/getAttribute:到指定的作用范围内取/放属性数据,Servlet定义的三个作用范围分别使用如下常量代表:
               SCOPE_REQUEST :代表请求作用范围；
               SCOPE_SESSION :代表会话作用范围；
               SCOPE_GLOBAL_SESSION :代表全局会话作用范围,即ServletContext上下文作用范围。

   		得到本地的Servlet API。
   		nativeWebRequest.getNativeRequest
   		nativeWebRequest.getNativeResponse


   	  第四种
   		HttpSession
   		public String session(HttpSession session) {
   			System.out.println(session);
   			return "success";
   		}
   		注意:session访问不是线程安全的,如果需要线程安全,需要自己手动的设置AnnotationMethodHandlerAdapter或RequestMappingHandlerAdapter的synchronizeOnSession属性为true,即可线程安全的访问session。
   		在spring2.5中是AnnotationMethodHandlerAdapter
   		在spring3中是RequestMappingHandlerAdapter.


   	  第五种
   		命令/表单对象(也可以是是自定义对象 例如User)
   		SpringMVC能够自动将请求参数绑定到功能处理方法的命令/表单对象上。

   		这里说的命令/表单对象并不需要实现任何接口，仅是一个拥有若干属性的POJO类对象

   		例如:
   		@RequestMapping(value = "/create"
   		public String toCreateUser(HttpServletRequest request,User user) {
   			return null;
   		}
   		如果提交的表单(包含username和password文本域),将自动将请求参数绑定到命令对象user中去。


   	  第六种
   		Model、Map、ModelMap
   		SpringMVC提供Model、Map或ModelMap让我们能去封装/处理模型数据。
   		例如:
   		@RequestMapping(value="/model")
   		public String test(Model m1, Map<String,Object> m2, ModelMap m3) {
   			m1.addAttribute("a", "a");
   			m2.put("b", "b");
   			m3.put("c", "c");
   			System.out.println(m1 == m2);
   			System.out.println(m2 == m3);
   			System.out.println(m1.getClass());
   			System.out.println(m2.getClass());
   			System.out.println(m3.getClass());
   			return "success";
   		}
   		虽然此处注入的是三个不同的类型(Model model, Map model2, ModelMap model3),但三者是同一个对象


   	  第七种
   		HttpEntity<T>和ResponseEntity<T>

   		例如:HttpEntity的使用
   		@RequestMapping(value="test")
   		public String  test(HttpEntity<String> httpEntity){
   			//获得请求中的所有的header部分
   			HttpHeaders headers = httpEntity.getHeaders();
   			//获得请求中的所有的body部分
   			String body = httpEntity.getBody();

   			Set<Entry<String,List<String>>> set = headers.entrySet();
   			StringBuffer s = new StringBuffer();
   			for(Entry<String,List<String>> entry:set){
   				String key = entry.getKey();
   				s.append(key+": ");
   				List<String> list = entry.getValue();
   				for(String value:list){
   					s.append(value+" ");
   				}
   				System.out.println(s.toString());
   				s.setLength(0);
   			}
   			System.out.println("----------------");
   			System.out.println("body = "+body);

   		}

   		例如:ResponseEntity的使用,可以自定义响应的各个部分
   		@RequestMapping("/test")
   		public ResponseEntity<String> test(){
   			//创建响应头对象
   			HttpHeaders headers = new HttpHeaders();

   			//创建MediaType对象
   			MediaType mt = new MediaType("text","html",Charset.forName("UTF-8"));
   			//设置ContentType
   			headers.setContentType(mt);

   			//准备好相应体
   			String content = new String("hello world");

   			//根据响应内容/响应头信息/响应状态码创建响应对象
   			ResponseEntity<String> re = new ResponseEntity<String>(content,headers,HttpStatus.OK);

   			//返回ResponseEntity对象
   			return re;
   		}


   	  第八种
   		SessionStatus

   		SessionStatus中的setComplete()方法可以用来清除使用@SessionAttributes注解放到session中的数据,下面介绍注解的例子的例子中会说明这个问题
   		@RequestMapping("/test")
   		public String test(SessionStatus status)


   	  第九种
   		RedirectAttributes
   		问题描述:
   		当前一个表单提交(post)给Controller之后,Controller处理完带着数据(msg="添加成功")进行服务器内部跳转到一个成功页面,页面里使用EL表达式拿出msg中的值并显示出来,这个时候用户按F5刷新,那么表单数据会再被提交一次。
   		如果上述过程中不是使用服务器内部跳转而是使用客户端重定向,那么用户在成功页面按F5刷新就不能重新提交表单了,但是由于使用了重定向,那么之前我们放在request范围的数据就拿不到了。

   		RedirectAttributes可以帮我们解决这个问题,既要使用客户端重定向,又要把一些有用的数据保留到下一次重定向的请求之中

   		例如:
   		@RequestMapping(value="/user/add",method=RequestMethod.POST)
   		public String addUser(User user,RedirectAttributes redirectAttributes){
   			System.out.println("user = "+user);
   			redirectAttributes.addFlashAttribute("msg", "添加用户成功");

   			//这里不能使用servlet重定向的方式
   			//response.sendRedirect()
   			//要使用springMVC提供的重定向方式
   			return "redirect:/user/add/success";
   		}
   		@RequestMapping("/user/add/success")
   		public String index(){
   			return "success";
   		}

   		客户端重定向之后,用户可以在添加成功页面看到提示信息,但是用户按F5刷新之后,提示信息就没有了,变量msg只是被保存到了一下次重定向的请求之中。页面中使用${requestScope.msg }即可获得数据,当然也可以${msg}

   	  第十种
   		BindingResult
   			BindingResult对象里面可以保存SpringMVC数据校验中的错误信息,要结合数据校验功能来使用

   	  其他
   		除了以上几种类型参数之外,还支持一些其他的类型,如:Errors、Locale、Principal、UriComponentsBuilder等


    ---------功能处理方法中的注解

   	2)@RequestParam绑定单个请求参数值
   	用于将请求参数区数据映射到功能处理方法的参数上
   	public String test(@RequestParam String username)
   	请求中包含username 参数(如/test?username=tom),则自动传入。
   	注:这时候也可以简写为
   	public String test(String username)

   	如果url为/test?name=tom,即俩边参数名不一致,那么就需要手动指定
   	public String test(@RequestParam("name") String username)

   	@RequestParam注解中主要有哪些参数
   		value:参数名字,即入参的请求参数名字
   		required:是否必须,默认是true
   		defaultValue:默认值,表示如果请求中对应参数时则采用此默认值,默认值可以是spring中的SpEL 表达式,如
   		"#{systemProperties['java.vm.version']}"。

   	注意:systemProperties是spring自动方法ioc容器中的一个Properties对象,里面方法中很多系统变量,要取值只需#{systemProperties['key']}即可
   	注:后面知识点中有对spEL的更多介绍和使用

   	3)@PathVariable绑定URI模板变量值

   		用于将请求URL中的模板变量映射到功能处理方法的参数上。

   		@RequestMapping(value="/users/{userId}/topics/{topicId}")
   		public String test(@PathVariable int userId,
   		@PathVariable int topicId){
   			return "index";
   		}

   		如请求的 URL为"/users/123/topics/456",则自动将URL 中模板变量{userId}和{topicId}绑定到通过@PathVariable注解的同名参数上,即入参后userId=123、topicId=456。
   		如果参数不同名,则需要自己手动指定
   		@RequestMapping(value="/users/{uid}/topics/{tid}")
   		public String test(@PathVariable("uid") int userId,
   		@PathVariable("tid") int topicId){
   			return "index";
   		}


   		注意:这种方法还可以自动的把数据放到模型中,在视图渲染的时候使用,例如:
   		//放到模型中的数据的key为name
   		@RequestMapping(value="/user/{name}")
   		public String test(@PathVariable String name)
   		或者:
   		//放到模型中的数据的key为name
   		@RequestMapping(value="/user/{name}")
   		public String test(@PathVariable("name") String username)

   		//运行报错
   		@RequestMapping(value="/user/{name}")
   		public String test(@PathVariable String username)


   	4)@CookieValue绑定Cookie数据值
   		用于将请求的Cookie数据映射到功能处理方法的参数上。
   		public String test(@CookieValue(value="JSESSIONID", defaultValue="") String sessionId)
   		如上配置将自动将JSESSIONID 值入参到sessionId 参数上,defaultValue 表示Cookie中没有JSESSIONID时默认为空。

   		传入参数类型也可以是javax.servlet.http.Cookie类型。
   		public String test(@CookieValue(value="JSESSIONID", defaultValue="") Cookie cookie)



   	5)@RequestHeader 绑定请求头数据
   		用于将请求的头信息区数据映射到功能处理方法的参数上。
   		@RequestMapping(value="/header")
   		public String test(@RequestHeader("User-Agent") String userAgent,
   		@RequestHeader(value="Accept") String[] accepts)

   		如上配置将自动将请求头"User-Agent"的值,入参到userAgent参数上,并将"Accept"请求头值入参到accepts参数上。


   	6)@ModelAttribute 绑定请求参数到命令/表单对象
   		该注解具有如下三个作用:

   		1.绑定请求参数到命令对象,同时将对象存放到模型中(可以指定存放的名字)
   			例如在用户登录时,我们需要捕获用户登录的请求参数(用户名、密码)并封装为用户对象,此时我们可以使用@ModelAttribute绑定多个请求参数到我们的命令对象。
   			public String test(@ModelAttribute("my_user") User u)

   			和上面接收到的"第五种"情况一样,只是此处多了一个注解@ModelAttribute("my_user"),它的作用是将该绑定的命令对象以"my_user"为名称添加到模型对象中供视图页面展示使用。我们此时可以在视图页面使用${my_user.username}来获取绑定的命令对象的属性。
   			如果不写@ModelAttribute("my_user")这个注解,那么默认添加到模型中的名字是该类型的类名首字母小写,例如这里便是user,页面中取值就需要这样${user.username}

   		例如:
   		@RequestMapping("/test5_1")
   		public String test5_1(User u){
   			//这种情况 会把参数对象u自动的绑定到模型中
   			//绑定的key值为user  类型的首字母小写
   			System.out.println("u ="+u);

   			return "index";
   		}

   		@RequestMapping("/test5_2")
   		public String test5_2(User u,Model model){
   			//这种情况 也会把参数对象u自动的绑定到模型中
   			//绑定的key值为user  类型的首字母小写
   			//同时我们又手动的把对象u绑定到了模型中,key值为u
   			System.out.println("u ="+u);
   			model.addAttribute("u", u);

   			return "index";
   		}

   		@RequestMapping("/test5_3")
   		public String test5_3(@ModelAttribute("u") User u){
   			//这种情况 使用注解把参数对象u绑定到模型中
   			//绑定的key值也是自动指定的为u
   			System.out.println("u ="+u);

   			return "index";
   		}



   		2.在功能处理方法执行前,向模型中添加数据
   			@ModelAttribute("cityList")
   			public List<String> cityList(String username) {

   				return Arrays.asList("北京", "山东");
   			}
   			如果当前模型中没有名字为cityList的数据时,如上代码会在执行处理器中任意功能处理方法之前执行,并将返回值自动添加到模型对象中,在功能处理方法中调用Model对象中的方法containsAttribute("cityList")将会返回true。

   			注意:模型中数据的作用范围是request级别的
   			注意:此方法中依然是可以接收本次请求的参数的,默认和客户端所传参数名字保持一致,也可以使用@RequestParam指定参数名

   			注意:如何有俩个同名的命令对象,如下
   			@ModelAttribute("user")
   			public User getUser(String username) {
   				User user = new User();
   				user.setUsername("briup");
   				return user;
   			}

   			@RequestMapping(value="/model")
   			public String test1(@ModelAttribute("user") User user, Model model){
   				//输出结果为briup
   				System.out.println(user.getUsername());

   				//返回值是true
   				System.out.println(user == model.asMap().get("user"));
   				return "index";
   			}

   			说明springMVC对于模型中重名的对象,不会重复创建,默认模型中已经有了这个名字的对象,那么就直接拿出来使用

   			例如:
   			@ModelAttribute("user")
   			public User getUser(){
   		//		System.out.println("in getUser");
   				User user = new User(1L,"zhangsan",20);
   				return user;
   			}

   			@RequestMapping("/test5_4")
   			public String test5_4(User u){
   				System.out.println("u ="+u);
   				return "index";
   			}

   			上面第一个方法getUser及其注解的含义:
   			当客户端访问/test5_4的时候,SpringMVC会先检查一下模型中有没有一个key为user的数据,如果有就算了,如果没有就会调用getUser方法把返回值作为数据存放到模型中,并且key值为user

   			上面第二个方法test5_4及其注解的含义:
   			首先test5_4(User u)这样写,相当于:
   			test5_4(@ModelAttribute User u)
   			这样又相当于
   			test5_4(@ModelAttribute("user") User u)
   			它的意思是先从模型中查找有没有一个key为user的对象,如果有就拿出来使用,如果没有那么就调用User类中的无参构造器创建一个新对象来使用,并且在最后还把这个对象存放到模型中,key值为user


   		3.把功能处理方法的返回值添加到模型数据中
   			@RequestMapping(value="/index")
   			public @ModelAttribute("u") User test3(){
   				User user = new User();
   				user.setUsername("tom");
   				user.setPassword("123");
   				return user;
   			}

   			注意:这时候SpringMVC会根据RequestToViewNameTranslator进行逻辑视图名的翻译,这个例子中也就会把"index"作为逻辑视图名进行解析

   			注意:对于集合类型(Collection接口的实现者们,包括数组),生成的模型对象属性名为"简单类名(首字母小写)"+"List",如List<String>生成的模型对象属性名"stringList",List<User>生成的模型对象属性名为"userList"。
   			例如:
   			public @ModelAttribute List<String> test()
   			public @ModelAttribute List<User> test()



   	7)@SessionAttributes绑定命令对象到session
   		@SessionAttributes(String[] value,Class[] type)
   		@SessionAttributes(value={},types={})

   		@SessionAttributes(value={"user"})写在处理器类上面
   		表示将模型数据中的名字为"user" 的对象存储到会话中，此处value指定将模型数据中的哪些数据（名字进行匹配）存储到会话中，此外还有一个types属性表示模型数据中的哪些类型的对象存储到会话范围内，如果同时指定value和types属性则那些名字和类型都匹配的对象才能存储到会话范围内。

   		注意,模型数据的作用范围是request级别的,所以一次请求过后,之前模型中的数据就没有了,@SessionAttributes注解可以将当前模型中指定的数据存放到session中,并且还可以从session中把指定数据取出来返回模型中。

   		1.如果模型里有名字为user的数据,并且使用了@SessionAttributes("user"),那么这个模型中的数据user会被放到session中
   		2.如果要从模型中拿名字为user的数据,模型中没有,这个时候就拿不到了,但是这个时候使用了@SessionAttributes("user"),那么它会帮我们把数据从session取出来放到模型中

   		所以处理器类的上面有没有加@SessionAttributes("user")注解,会影响到我们使用下面方式是否能拿到值
   		@RequestMapping("/session")
   		public String session(User u) {
   			System.out.println(u);
   			return "index";
   		}
   		默认只是从模型中拿名字叫user的值,如果加了@SessionAttributes("user")这个注解,还可以拿到session中的user对象

   		也可以指定用哪个名字拿值,例如:
   		@RequestMapping("/session")
   		public String session(@ModelAttribute("my_user") User u) {
   			System.out.println(u);
   			return "index";
   		}

   		也可以使用SessionStatus对象的方法把@SessionAttributes指定的数据从session中清除掉
   		@RequestMapping("/session")
   		public String session(User u,SessionStatus status) {
   			if(true){
   				//从session中清除注解中指定的数据
   				status.setComplete();
   			}
   			System.out.println(u);
   			return "index";
   		}


   	8)@Value绑定SpEL表示式
   		用于将一个SpEL表达式结果映射到到功能处理方法的参数上。
   		public String test(@Value("#{systemProperties['java.vm.version']}") String jvmVersion){
   			System.out.println(jvmVersion);
   			return "index";
   		}

   		SpEL表达式的使用,例如:
   		取名字为stu的bean的name字段的值,这里指的是property
   		public String test(@Value("#{stu.name}") String username)

   		对其他bean中某个方法的引用
   		public String test(@Value("#{stu.sayHello()}") String username)
   		public String test(@Value("#{stu.sayHello('tom')}") String username)

   		表达式(?.)可以确保在sayHello()返回不为空的情况下调用toUpperCase()方法,如果返回空那么不继续调用后面的方法
   		public String test(@Value("#{stu.sayHello()?.toUpperCase()}") String username)

   		如果要调用的某个类是外部类,而不是spring中定义的bean,使用表达式T()
   		public String test(@Value("#{T(java.lang.Math).random()}") String username)


   		例如:
   		@RequestMapping("/test7_1")
   		public String test7_1(@Value("hello") String msg){
   			//注意这里不是使用msg来接收客户端参数(也接收不到)
   			//而是使用@Value注解来给msg赋值
   			//同时这里面可以使用SpEL
   			System.out.println("msg = "+msg);
   			return "index";
   		}

   		@RequestMapping("/test7_2")
   		public String test7_2(@Value("#{util.sayHello()}") String msg){
   			System.out.println("msg = "+msg);
   			return "index";
   		}


   	9)@InitBinder注解
   		可以解决类型转换的问题

   		例如一个表单提交数据给Controller,表单中有日期数据
   		@Controller
   		public class InitBinderController{

   			@RequestMapping(value="/register",method=RequestMethod.GET)
   			public String registerPage(){
   				return "register";
   			}

   			@RequestMapping(value="/register",method=RequestMethod.POST)
   			public String register(User user){
   				System.out.println("user = "+user);
   				return "index";
   			}
   		}

   		表单提交的时候有一个字符串形式的日期数据"1999-10-23",SpringMVC默认不支持这个格式的转换,所以需要手动配置日期类型的转换,否则会报错。
   		在这个Controller中加入写一个转换的方法,加上@InitBinder即可
   		@Controller
   		public class InitBinderController{

   			@InitBinder
   			public void test(WebDataBinder binder){
   				SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
   				//true表示允许为空
   				binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true));
   			}

   			@RequestMapping(value="/register",method=RequestMethod.GET)
   			public String registerPage(){
   				return "register";
   			}

   			@RequestMapping(value="/register",method=RequestMethod.POST)
   			public String register(User user){
   				System.out.println("user = "+user);
   				return "index";
   			}
   		}




   		在Spring3中引入了一个Converter接口，它支持从一个任意类型转为另一个任意类型。
   		例如:
   		自己编写的转换器代码:
   		public class StringToDateConverter implements Converter<String, Date>{
   			private SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
   			@Override
   			public Date convert(String str) {
   				Date date = null;
   				try {
   					if(str!=null&&!"".equals(str.trim())){
   						date = dateFormat.parse(str);
   					}
   				} catch (ParseException e) {
   					e.printStackTrace();
   				}
   				return date;
   			}
   		}

   		spring的配置文件:例如spring的一个工厂类,产生一个转换服务,同时把我们自己的转换器注入进去,可以有多个
   		<bean name="formatService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
   			<property name="converters">
   				<set>
   					<bean class="com.briup.web.converter.StringToDateConverter"></bean>
   				</set>
   			</property>
   		</bean>
   		//在mvc标签中指定这个转换服务器
   		<mvc:annotation-driven conversion-service="formatService"/>


   		还有另外一种解决日期的方式,就是利用spring提供的一个专门针对日期转换的注解:@DateTimeFormat(pattern="yyyy-MM-dd")
   		例如:
   		public class User {
   			private String username;
   			private String password;
   			@DateTimeFormat(pattern="yyyy-MM-dd")
   			private Date dob;

   			get/set
   		}
   		注意这个时候就不需要我们再写自定义的转换器了,但是如果是其他类型的转换,我们还得需要自己编写自定义的类型转换器


   	10).@Scope注解
   		Controller默认情况下和servlet一样也是单例,但是spring提供了一个@Scope注解可以让Controller对象变为非单例,只需在Controller类上面加入@Scope("prototype")即可

   		例如:
   		@Controller
   		@RequestMapping("/hello")
   		@Scope("prototype")
   		public class HelloWorldController{
   			....
   			....
   		}

   	11)@RequestBody注解
   		可以接收客户端ajax请求中的json数据并且转换为对象,但是只能接收post请求中的数据,因为post请求的数据在请求体中(request-body).
   		需要引入操作json的相关jar包:
   			jackson-core-2.8.5.jar
   			jackson-annotations-2.8.5.jar
   			jackson-databind-2.8.5.jar
   			或者
   			jackson-mapper-asl-1.9.13.jar
   			jackson-core-asl-1.9.13.jar

   		注意:在javascript中,json对象和字符串之间的转换:
   			JSON.stringify(obj)将JSON转为字符串。
   			JSON.parse(string) 将字符串转为JSON格式；

   		例如:
   			处理器中代码:
   			@RequestMapping(value="/json/update",consumes="application/json",method=RequestMethod.POST)
   			public void update(@RequestBody User user,Writer out)throws Exception{
   				System.out.println("user = "+user);
   				out.write("helloworld");
   			}

   			页面js中代码:
   			注意:http中的Content-Type,在jquery中是contentType
   			$("#btn").on("click",function(){
   				var json = {username:"tom",password:"123",dob:"1999-10-27"};
   				$.ajax({
   					type:"post",
   					url:"json/update",
   					contentType:"application/json",
   					data:JSON.stringify(json),
   					dataType:"text",
   					success:function(data){
   						console.log("data = "+data);
   					}
   				});
   			});

   			客户端使用ajax发送json数据给Controller,Controller里面接收json数据并且转换为对象
   			1.ajax请求发送的时候要指定为post方式
   			2.ajax请求发送的时候要指定contentType:"application/json"
   			3.ajax请求发送的时候要把json对象转换为字符串再发送
   			4.Controller中要使用@RequestBody指定接收数据的参数
   			5.项目中要引入json相关的jar包
   			6.如果此ajax请求还希望Controller返回的数据也是json格式的,那么需要在发送ajax请求的时候指定dataType:"json",
   			7.Controller中的方法要返回json格式的数据给客户端,可以使用@ResponseBody标签 或者 在方法中自己使用response对象获得io流给客户端写回去

   			注意:
   			ajax发送请求的时候,请求头中的Content-Type默认值是: application/x-www-form-urlencoded,表示当前请求中如果有数据的话,将会是key=value&key=value的形式


   	12)@ResponseBody注解
   		该注解用于将处理器中功能处理方法返回的对象，经过转换为指定格式后，写入到Response对象的body数据区(响应正文).一般返回的数据不是html标签的页面，而是其他某种格式的数据时使用,例如给ajax请求返回json数据.
   		例如:在@RequestBody的例子中进行修改
   		处理器中代码:添加了@ResponseBody,修改了方法的返回值
   			@RequestMapping(value="/update",consumes="application/json",method=RequestMethod.POST)
   			@ResponseBody
   			public User update(@RequestBody User user)throws Exception{
   				System.out.println("user = "+user);
   				user.setUsername("张三");
   				user.setPassword("123");
   				user.setDob(new Date());
   				return user;
   			}

   			页面js中代码: 注意这里的dataType属性的值
   			$("#btn").on("click",function(){
   				var json = {username:"tom",password:"123",dob:"1999-10-27"};
   				$.ajax({
   					type:"post",
   					url:"json/update",
   					contentType:"application/json",
   					data:JSON.stringify(json),
   					dataType:"json",
   					success:function(data){
   						console.log("data = "+data);
   						console.log(data.username);
   						console.log(data.password);
   						console.log(data.dob);
   					}
   				});
   			});

   		这里还是会有日期的问题,就是把user对象放入响应正文返回给客户端后,被转换为了json对象,从firebug中可以看出,这个返回的json对象为{"username":"张三","password":"123","dob":1478621620119},它默认把dob这个日期对象转为了一个时间戳

   		如果我们想按照自己的日期格式进行转换,那么需要这样处理:
   		自定义一个json的日期类型格式化类:
   		public class DateJsonSerializer extends JsonSerializer<Date> {
   			@Override
   			public void serialize(Date value, JsonGenerator jgen,
   					SerializerProvider provider) throws IOException,
   					JsonProcessingException {
   				 SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");
   				 String formattedDate = formatter.format(value);
   				 jgen.writeString(formattedDate);
   			}
   		}

   		在User类中的getDob方法上添加注解
   		@JsonSerialize(using=DateJsonSerializer.class)
   		public Date getDob() {
   			return dob;
   		}


   		@ResponseBody注解可以处理以下常见类型的返回值,如果可以的话还会把返回值转换为json格式字符串
   		1.单值(基本数据类型和字符串)
   			这时候ajax中要设置dataType: "text"
   		2.bean对象(例如User对象、Student对象等,对象中需要有property)
   		3.数组
   		4.List/Set集合
   		5.Map集合


